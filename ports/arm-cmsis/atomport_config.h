/*
 * Copyright (c) 2017, Daniel Glasser. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. No personal names or organizations' names associated with the
 *    Atomthreads project may be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE ATOMTHREADS PROJECT AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/* atomport_config.h : Application specific configuration for the CMSIS
 * based atomthread port layer for the ARM Cortex-M in STM32xxxx MCU SoCs.
 *
 */
#pragma once
#if !defined(ATOMPORT_CONFIG_H__INCL__)
#define ATOMPORT_CONFIG_H__INCL__

/* The following GCC pre-defined macros may be of use.  For each, the
 * values for known MCU SoCs are shown.
 *                             (1) (2)  (3) (4)
 *   Symbol                    m4f m7fd m3	m7fs
 *   __arm__					1	1	1	1
 *   __ARM_32BIT_STATE			1	1	1	1
 *   __ARM_ARCH					7	7	7	7
 *   __ARM_ARCH_7EM__			1	1	-	1
 *   __ARM_ARCH_7M__			-	-	1	-
 *   __ARM_ARCH_EXT_IDIV__		1	1	1	1
 *   __ARM_ARCH_ISA_THUMB		2	2	1	1
 *   __ARM_ARCH_PROFILE			77	77	77	77
 *   __ARM_ASM_SYNTAX_UNIFIED__	1	1	1	1
 *   __ARM_EABI__				1	1	1	1
 *   __ARM_FEATURE_CLZ			1	1	1	1
 *   __ARM_FEATURE_DSP			1	1	-	1
 *   __ARM_FEATURE_FMA			1	1	-	1
 *   __ARM_FEATURE_IDIV			1	1	1	1
 *   __ARM_FEATURE_LDREX		7	7	7	7
 *   __ARM_FEATURE_QBIT			1	1	1	1
 *   __ARM_FEATURE_SAT			1	1	1	1
 *   __ARM_FEATURE_SIMD32		1	1	-	1
 *   __ARM_FEATURE_UNALIGNED	1	1	1	1
 *   __ARM_FP					4	14	-	4
 *   __ARM_PCS_VFP				1	1	-	1
 *   __ARM_SIZEOF_MINIMAL_ENUM	1	1	1	1
 *   __ARM_SIZEOF_WCHAR_T		4	4	4	4
 *   __ARMEL__					1	1	1	1
 *   __BIGGEST_ALIGNMENT__		8	8	8	8
 *   __CHAR_UNSIGNED__			1	1	1	1
 *   __FP_FAST_FMA				-	1	-	-
 *   __FP_FAST_FMAF				1	1	-	1
 *   __FP_FAST_FMAL				-	1	-	-
 *   __GCC_IEC_559				0	2	0	0
 *   __GCC_IEC_559_COMPLEX		0	2	0	0
 *   __SOFTFP__					-	-	1	-
 *   __thumb__					1	1	1	1
 *   __thumb2__					1	1	1	1
 *   __THUMB_INTERWORK__		1	1	1	1
 *   __THUMBEL__				1	1	1	1
 *   __VFP_FP__					1	1	1	1
 *
 * The above is based on the output from the following commands:
 *  1) arm-none-eabi-gcc -mcpu=cortex-m4 -mthumb -mfloat-abi=hard \
 *     					 -mfpu=fpv4-sp-d16 -E -dM x.c
 *     These are the options generated by stm32cubemx for a ac6 sw4stm32
 *     project for a STM32L476 MCU
 *  2) arm-none-eabi-gcc -mcpu=cortex-m7 -mthumb -mfloat-abi=hard \
 *                       -mfpu=fpv5-d16 -E -dM x.c
 *     These are the options generated by stm32cubemx for a ac6 sw4stm32
 *     project for a STM32F767 MCU
 *  3) arm-none-eabi-gcc -mcpu=cortex-m3 -mthumb -mfloat-abi=soft \
 *                       -E -dM x.c
 *     These are the options generated by stm32cubemx for a ac6 sw4stm32
 *     project for a STM32L103 MCU
 *  4) arm-none-eabi-gcc -mcpu=cortex-m7 -mthumb -mfloat-abi=hard \
 *                       -mfpu=fpv4-sp-d16 -E -dM x.c
 *     These are the options generated by stm32cubemx for a ac6 sw4stm32
 *     project for a STM32F767 MCU
 */

/* ATOMPORT_CONFIG_WITH_NEWLIB is defined when the c/c++ library is based on
 * Newlib (or newlib nano).  This only makes a difference for atomport-asm.S,
 * where it is used to define the symbol "__NEWLIB__"; in the C files, the
 * definition of that symbol is done by the standard library headers, but
 * atomport-asm.S does not include any of those.
 *
 * This has been tested with the environment and toolchain provided in the
 * AC6 SW4STM32/OpenSTM32 environment which uses a cross-GCC toolchain and
 * newlib.
 */
#define	ATOMPORT_CONFIG_WITH_NEWLIB

#if defined(SMARTFUSION2_MSS)
/* ATOMPORT_CONFIG_SF2_WITH_HAL_DRIVERS is defined when using the drivers
 * provided by Microsemi for the SmartFusion2 to be used on the hard
 * ARM Cortex-M3 core within that family of devices.
 */
#define ATOMPORT_CONFIG_SF2_WITH_HAL_DRIVERS
#else
/* ATOMPORT_CONFIG_STM32_WITH_HAL_DRIVERS is defined when using the STM32Cube
 * Hardware Abstraction Library (HAL) drivers.  When defined, some calls
 * to the HAL are included in the SysTick handler that make some HAL drivers
 * work better (or at all).
 */
#define ATOMPORT_CONFIG_STM32_WITH_HAL_DRIVERS
#endif /* defined(SMARTFUSION2_MSS) */

/* When ATOMPORT_CONFIG_SIMPLIFY_FIRST_THREAD is defined, the code to start
 * the first thread at start-up is simplified.  This was done to remove a
 * bunch of multi-register "pop" instructions that were somehow making the
 * JTAG connection unusable when debugging software the Cortex-M3 hard core
 * in the SmartFusion2 MSS block.  The first 'pop' with multiple registers
 * caused OCD to lose control over JTAG through a FlashPro-5 debugger cable.
 * (Also tried "ldmia" with the same results.)  Didn't have to single step,
 * so it was not just an issue with single-stepping multi-cycle instructions;
 * may be a ETM related issue.  Since this reduces code size, and works on
 * all ARM Cortex-Ms other than the V8M variants, I've left it in place.
 */
#define ATOMPORT_CONFIG_SIMPLIFY_FIRST_THREAD

/* ATOMPORT_CONFIG_MINIMIZE_CODE_SIZE removes some unnecessary register
 * value setup for stack frame creation, allowing existing values in
 * the stack memory to remain untouched.  This saves only 264 bytes in
 * the text section, but may be a valuable space savings in some cases.
 */
#define ATOMPORT_CONFIG_MINIMIZE_CODE_SIZE

/* Define ATOMPORT_CONFIG_HARDFAULT_HANDLER to enable the hard fault handler
 * in this ports "atomport.c".  Saves 72 bytes when not configured.
 */
#define ATOMPORT_CONFIG_HARDFAULT_HANDLER

/* Define ATOMPORT_CONFIG_SYSTICK_HANDLER to get the port defined version
 * of "SysTick_Handler()".  If this is not defined, user or board specific
 * code will need to call the atomthreads interrupt entry and exit functions
 * ("atomIntEnter()" and "atomIntExit()", respectively) and the atomthreads
 * timer tick function ("atomTimerTick()") as described in the atomthreads
 * documentation.  The port defined version is in "atomport.c"
 */
#define ATOMPORT_CONFIG_SYSTICK_HANDLER

/* GLASSER_DEBUG_INFO adds a field to the TCB (not port specific) and code
 * to some kernel functions to store the wait queue address a thread is
 * pended on when blocked so that it's easier to determine why a thread is
 * blocked.
 */
#define GLASSER_DEBUG_INFO	/* Adds some stuff to the TCB */

/* Define ATOMPORT_CONFIG_THREAD_PROFILE to store profiling information
 * for each thread on context switch.  This profiling is done using the
 * Data Watchpoint Trace logic in the Cortex-M, and has been tested on
 * the stm32f767zi, where the code right-shifts the cycle counter
 * value by 8 bits (divides by 256) to make it take longer for the
 * thread cycle count to overflow.
 */
#define ATOMPORT_CONFIG_THREAD_PROFILE

#endif /* !defined(ATOMPORT_CONFIG_H__INCL__) */

